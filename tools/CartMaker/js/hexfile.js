// Generated by Haxe 4.0.0-preview.5+7eb789f54
(function ($hx_exports) { "use strict";
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.prototype = {
	split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
};
var HexFile = $hx_exports["HexFile"] = function(code) {
	this.startAddress = 0;
	this.data = [];
	this.decode(code);
};
HexFile.prototype = {
	decodeHex: function(text,size,startIndex) {
		if(startIndex == null) {
			startIndex = 0;
		}
		var t = "0x" + HxOverrides.substr(text,startIndex,size);
		return Std.parseInt(t);
	}
	,decodeByte: function(text,startIndex) {
		if(startIndex == null) {
			startIndex = 0;
		}
		var t = "0x" + HxOverrides.substr(text,startIndex,2);
		return Std.parseInt(t);
	}
	,decodeWord: function(text,startIndex) {
		if(startIndex == null) {
			startIndex = 0;
		}
		var t = "0x" + HxOverrides.substr(text,startIndex,4);
		return Std.parseInt(t);
	}
	,merge: function() {
		var merged = [];
		var previousChunk = { address : this.data[0].address, data : []};
		var _g = 0;
		var _g1 = this.data;
		while(_g < _g1.length) {
			var chunk = _g1[_g];
			++_g;
			if((previousChunk.address + previousChunk.data.length | 0) == chunk.address) {
				previousChunk = { address : previousChunk.address, data : previousChunk.data.concat(chunk.data)};
			} else {
				merged.push(previousChunk);
				previousChunk = chunk;
			}
		}
		merged.push(previousChunk);
		this.data = merged;
	}
	,decode: function(code) {
		var regex = new EReg("\n","gm");
		var lines = regex.split(code);
		var baseAddress = 0;
		var segmentAddress = 0;
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			if(StringTools.startsWith(line,":")) {
				if(line.length >= 9) {
					var t = "0x" + HxOverrides.substr(line,7,2);
					var recordType = Std.parseInt(t);
					var t1 = "0x" + HxOverrides.substr(line,1,2);
					var byteCount = Std.parseInt(t1);
					var t2 = "0x" + HxOverrides.substr(line,3,4);
					var address = Std.parseInt(t2);
					if(line.length < 11 + byteCount * 2) {
						return;
					}
					var dataStart = 9;
					if(recordType != 0) {
						baseAddress = 0;
					}
					switch(recordType) {
					case 0:
						var range = (baseAddress + segmentAddress | 0) + address;
						var _g1 = [];
						var _g11 = 0;
						var _g2 = byteCount;
						while(_g11 < _g2) {
							var i = _g11++;
							var t3 = "0x" + HxOverrides.substr(line,dataStart + i * 2,2);
							_g1.push(Std.parseInt(t3));
						}
						var range1 = { "address" : range | 0, "data" : _g1};
						this.data.push(range1);
						break;
					case 1:
						return;
					case 2:
						var t4 = "0x" + HxOverrides.substr(line,dataStart,4);
						segmentAddress = Std.parseInt(t4) << 4;
						break;
					case 3:
						var t5 = "0x" + HxOverrides.substr(line,dataStart,4);
						var t6 = "0x" + HxOverrides.substr(line,dataStart + 4,4);
						this.startAddress = (Std.parseInt(t5) << 4) + Std.parseInt(t6);
						break;
					case 4:
						segmentAddress = 0;
						var t7 = "0x" + HxOverrides.substr(line,dataStart,4);
						baseAddress = Std.parseInt(t7) << 16;
						break;
					case 5:
						var t8 = "0x" + HxOverrides.substr(line,dataStart,4);
						var t9 = "0x" + HxOverrides.substr(line,dataStart + 4,4);
						this.startAddress = (Std.parseInt(t8) << 16) + Std.parseInt(t9);
						break;
					}
				}
			}
		}
	}
};
var HxOverrides = function() { };
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var Std = function() { };
Std.parseInt = function(x) {
	var v = parseInt(x, x && x[0]=="0" && (x[1]=="x" || x[1]=="X") ? 16 : 10);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringTools = function() { };
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return HxOverrides.substr(s,0,start.length) == start;
	} else {
		return false;
	}
};
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);
