<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Kwak-8 by Lerc</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <link rel="stylesheet" href="stylesheets/font-awesome.min.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <style>
    noytable {
  	background-color: azure;
  	text-align: center;
    }
    notd {
  	padding:2px 8px;
    border: 1px solid black;
  	box-shadow: 0px 0px 3px 1px;
    }
    .diagram {
  	margin:10px;
  	padding: 8px 8px;
  	width : 300px;
  	font-size: smaller;
    }
    .diagram>div>h4 {
  	margin: 0;
    }
    .diagram>div {
  	background-color : oldLace;
  	padding: 8px 8px;
  	border: 1px solid black;
  	width :80%
    }
    .diagram>i {
      font-size: 32px;
    }
    </style>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Kwak-8</h1>
        <p>An 8 bit fantasy computer</p>
        <p class="view"><a href="https://github.com/Lerc/kwak-8">View the Project on GitHub <small>Lerc/kwak-8</small></a></p>
        <ul class="downloads">
          <li><a href="https://github.com/Lerc/kwak-8/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/Lerc/kwak-8/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/Lerc/kwak-8">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>

      <section>
      The KWAK-8 never existed as a physical computer.   Like <a href="http://www.pico-8.com/">Lexaloffle's excellent PICO-8</a>.
      The KWAK-8 is an emulated system for enthusiasts of constrained environments.<p/>


      When compared to the PICO-8 The KWAK-8 programming interface is much lower level.  The KWAK-8 uses an
      instruction set compatible with the Arduino, and all interaction with the outside world is done
      through IO/Ports.   Unlike emulators for Actual computers in the past, The KWAK-8 is much less
      dependent on precise timing and can thus be emulated much more efficiently.<p>
      <center>
      <div class="specs">
      <table>
      <tr><td>Instruction set</td><td>8-bit AVR</td></tr>
      <tr><td>RAM</td><td>64k</td></tr>
      <tr><td>ROM</td><td>128k</td></tr>
      <tr><td>Display</td><td>240x180<br><small>(hires mode 480x360)</small></td></tr>
      <tr><td>Colours</td><td>16<sup>†</sup>  <img src="images/Arne16.png" alt="Arne's 16 coolour palette"></td></tr>
      <tr><td>Speed</td><td>8Mhz<br><small>(probably)</small></td></tr>
      <tr><td>Audio</td><td>None yet, planned</td></tr>
      <tr><td>Storage</td><td>None yet,planned</td></tr>
      </table>
      <small>†256 colours available with CPU intensive PixelWriting.</small>

</div>
      </center>
      To give you an idea of the reolution. Here's a mockup at 240x180 using the 16 colour palette.
      <center>
      <img src="images/QuiteFresh_Arne16_240x180.png"> by <a href="http://quitefreshgames.tumblr.com/">Stefan Åhlin</a>
      </center>

      Making the instruction set compatable with 8 the 8-bit avr means, that many tools designed for the Arduino ecosystem can be
      repurposed to work on the Kwak-8.    This includes Assemblers, compilers and interpreted languages.

      The 8-bit AVR compatible instruction set means many tools designed for micro-controllers can be used with the KWAK-8.
      You can write programs in assembly, C, or a variety of languages that already have AVR support.
      <p/>

      </section>

      <section>
      The main difference between the Kwak-8 architecture and real 8-bit computers and consoles is how they manage the display.
      Most of the classic 8-bit computers connected to a television or monitor and generated their own image
      to send out in the video signal.   The video image was generated as needed,  just in time for the video beam to pass.  There was not
      nearly enough memory available at the time to provide a framebuffer with a ready made image.   The
      consequence of this is that the image itself was a transient thing, with no real existence outside
      of the time between data-fetch and pixel output.
      <p/>

      The ephemeral nature of the image is what lead to a lot of amazing tricks being performed on
      the machines.  Hardware resources can be re-purposed multiple times during a video frame as long
      as they are in the right place for the pixels currently being output.<p/>

      What was a boon for old hardware is a drain on emulators though.  To accurately emulate those
      old machines, you need incredibly precise timing.   Programs had to get all of their ducks in a row on
      a deadline measured in microseconds.  Emulators have to note not only what happened, but when it
      happened if they want to accurately reproduce the behaviour.<p/>


      A Video beam output could be considered a write only display, with the constraint that the image
      must be written serially and with precise timing. The KWAK-8 reduces emulation cost by relaxing
      those constraints.  The display is still a write only device, but pixels may be written at any time
      and need not be strictly serial. This means that an entire class of tricks that old computers could
      do are not available in this emulator.  There are no raster interrupts and there is no beam-racing.<p/>

      In compensation, what is provided is an emulated hardware mechanism more appropriate to
      an emulator that is backed by a frame-buffer.

      There are 3 basic forms of writing to the display device.

      <ul>
      <li> <h4>Display modes </h4>  These set all of the pixels on the output display reading
      from RAM and hardware registers.  The translation method of data to pixels is dependent on the mode
      <li> <h4>Blitter.</h4> You can write rectangles of data to screen in pixel formats of 2,3,4,8 pixels per byte.
      	  Blits can be X-flipped, Y-Flipped, X-Doubled, Y-Doubled, and support color 0 transparency.
      </li>
      <li>
        <h4>Serial Pixels</h4>You can position a pointer at a display position and serially write bytes
        to the display. This gives you access to 256 colour output.   There are also some blending options
        available to multiply or add to the existing pixels.  This is the most versatile display output
        mechanism but requires that the CPU do all of the display generation on its own.
      </li>
      </ul>

      A program might use any, or all three, of these mechanisms.  A common frame generation workflow might be
      <center>
      <div class="diagram">
        <div class="mode">
        <h4>Display Mode</h4>
        Background image
        </div>
        <i class="fa fa-arrow-down" ></i>
        <div class="blit">
        <h4>Blitter</h4>
        Moving 'Sprite' images
        </div>
        <i class="fa fa-arrow-down" ></i>
        <div class="pix">
        <h4>Serial pixels</h4>
      	special effects</div>
      </div>
      </center>

      Alternately a program might just do a single 240x180 Blit if it can spare the memory.  At 2 bytes per pixel a
      blit of 120 bytes wide and 180 high would fill the display but would also require a third of the RAM to hold
      the image.
      </section>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

  </body>
</html>
