<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Kwak-8 by Lerc</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Kwak-8</h1>
        <p>An 8 bit Emulator of some sort</p>
        <p class="view"><a href="https://github.com/Lerc/kwak-8">View the Project on GitHub <small>Lerc/kwak-8</small></a></p>
        <ul>
          <li><a href="https://github.com/Lerc/kwak-8/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/Lerc/kwak-8/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/Lerc/kwak-8">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="emulator-for-an-8-bit-machine-that-never-existed" class="anchor" href="#emulator-for-an-8-bit-machine-that-never-existed" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Emulator for an 8 bit machine that never existed</h1>

<h2>
<a id="hardware-specifications" class="anchor" href="#hardware-specifications" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hardware Specifications</h2>

<ul>
<li>8-bit AVR compatible instruction set.</li>
<li>128k Program memory</li>
<li>64k RAM</li>
<li>Display lowres(240x180) Hires(480x360)</li>
<li>Predominantly 16 color (more available in some circumstances)</li>
</ul>

<p>The Emulator aims to occupy a middle ground between 8-bit hardware of old and
efficient emulation.</p>

<p>Most emulators that emulate real systems have to emulate all of the timing and
hardware of a video beam based display. A Video beam output could be considered
a write only display, with the limitation that the image must be written serially
and with precice timing.</p>

<p>This emulator reduces the emulation cost by providing a write-only framebuffer
which must be updated every frame.  The framebuffer does not need precice timing
for each pixel, nor do the pixels need to be written in any particular order.</p>

<p>The framebuffer reduces the workload of the emulator greatly.  It does come at
a cost in that an entire class of tricks that old computers could do are not
available in this emulator.  There are no raster interrupts and there is no
beam-racing.</p>

<p>In compensation, what is provided is an emulated harware mechanism more
appropriate to a frame-buffer output.  You may think of this as a kind of blitter
if you wish.</p>

<p>There are 'display mode' operations that update the entire display from RAM and
hardware register settings.  There are image drawing fuctions that work analogous
to sprites, they get drawn on top of the dispaly mode with additional harware
operations.</p>

<p>There is a 256 colour serial output mode with some rudimentary blending options,
A clever person should be able to get 24 bit images out of the system, but not
likely at interactive speeds.</p>

<h2>
<a id="how-to-develop-for-it" class="anchor" href="#how-to-develop-for-it" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How To Develop for it?</h2>

<p>The emulator supports hex files.  You can write programs in assembler or compile
 c programs with avr-gcc.   </p>

<p>You can see a guide to developing C for AVR microcontrollers <a href="http://www.tldp.org/HOWTO/Avr-Microcontrollers-in-Linux-Howto/x207.html">here</a></p>

<p>avr-gcc seems to need a commandline option to specify the architecture.  Since
this is a device from my own imagination, it is not explicitly supported.  I use
<code>-mmcu=atmega1284p</code> which is close.</p>

<p>There are some example programs in the c directory.  There are examples that contain
the entire program in the .c file so you can see exactly what is needed.</p>

<h2>
<a id="hardware-registers" class="anchor" href="#hardware-registers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hardware Registers</h2>

<p>While the Instruction set is 8-bit AVR compatible.  The port mapped hardware is not intended to match any particular microcontroller.</p>

<p>The main Display output control is on port 0x40.  Writing 0x00 to that port puts the framebuffer onscreen in lowres mode.  Writing 0x01 displays hires mode.
Current Display control Operations are  </p>

<pre><code>    0x00 = Show Lowres display  (240x160)
    0x01 = Show Highres display (480x360);
    0x71 = blit 8 pixels per byte
    0x72 = blit 4 pixels per byte
    0x73 = blit 3 pixels per byte
    0x74 = blit 2 pixels per byte
    0x80 = Generate Mode 0   (fill framebuffer with 1.777bit per pixel data ( 16 bits per 9 pixels) )
</code></pre>

<p><em>The file IOMapping.txt lists all hardware ports.  Should there be an
inconsistancy in the documentation,  IOMapping.txt should be taken as
the correct form.</em></p>

<p>You may write byte sized pixels (one of 256 colours in a fixed palette)
to the framebuffer serially.
Logically the frameBuffer is 512x392 and addressed with a 18 bit address in
Ports 0x42,0x43,0x44  for SerialPixel address Low, Middle and High respectively.</p>

<p>Writing to port 0x45 sets the pixel at the pixel adrress to the colour of the value
written and advances the pixel address.</p>

<p>Writing to port 0x46 multiplies the pixel at the pixel adrress by the colour of the value
written and <strong>does not</strong> advance the pixel address.\</p>

<p>Writing to port 0x47 adds the pixel at the pixel adrress to the colour of the value
written and advances the pixel address.</p>

<p>You cannot write directly from Program Memory to the display.  Serial output must
be conveyed by the CPU. Display mode generators and blitting operations read from
RAM.  Consequently, image data will usually be transferred from Program Memory
to RAM before it can be actively used.</p>

<h2>
<a id="input" class="anchor" href="#input" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Input</h2>

<p>Reading from ports 0x48 to 0x4f provides state based inputs</p>

<pre><code>  input base = 0x48
  button_state_0 = input base + 0  Left Up Right Down Enter Esc Ctrl Shift  
  button_state_1 = input base + 1  A W D S SPACE Mouse1 Mouse2 Mouse3
  mouseX = input base +2
  mouseY = input base +3   mouse coordinates are in lowres pixels
  ticker = input base +4   increments on each frame of host device.
  timer  = input base +5   increments once per second
</code></pre>

<p>A serial input buffer is planned for keydown/keyup events but as yet no port
is assigned.</p>
      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/Lerc">Lerc</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
