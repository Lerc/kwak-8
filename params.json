{
  "name": "Kwak-8",
  "tagline": "An 8 bit Emulator of some sort",
  "body": "Emulator for an 8 bit machine that never existed\r\n===================================================\r\n\r\nHardware Specifications\r\n-----------------------\r\n  * 8-bit AVR compatible instruction set.\r\n  * 128k Program memory\r\n  * 64k RAM\r\n  * Display lowres(240x180) Hires(480x360)\r\n  * Predominantly 16 color (more available in some circumstances)\r\n\r\nThe Emulator aims to occupy a middle ground between 8-bit hardware of old and\r\nefficient emulation.\r\n\r\nMost emulators that emulate real systems have to emulate all of the timing and\r\nhardware of a video beam based display. A Video beam output could be considered\r\na write only display, with the limitation that the image must be written serially\r\nand with precice timing.\r\n\r\nThis emulator reduces the emulation cost by providing a write-only framebuffer\r\nwhich must be updated every frame.  The framebuffer does not need precice timing\r\nfor each pixel, nor do the pixels need to be written in any particular order.\r\n\r\nThe framebuffer reduces the workload of the emulator greatly.  It does come at\r\na cost in that an entire class of tricks that old computers could do are not\r\navailable in this emulator.  There are no raster interrupts and there is no\r\nbeam-racing.\r\n\r\nIn compensation, what is provided is an emulated harware mechanism more\r\nappropriate to a frame-buffer output.  You may think of this as a kind of blitter\r\nif you wish.\r\n\r\nThere are 'display mode' operations that update the entire display from RAM and\r\nhardware register settings.  There are image drawing fuctions that work analogous\r\nto sprites, they get drawn on top of the dispaly mode with additional harware\r\noperations.\r\n\r\nThere is a 256 colour serial output mode with some rudimentary blending options,\r\nA clever person should be able to get 24 bit images out of the system, but not\r\nlikely at interactive speeds.\r\n\r\nHow To Develop for it?\r\n----------------------\r\nThe emulator supports hex files.  You can write programs in assembler or compile\r\n c programs with avr-gcc.   \r\n\r\nYou can see a guide to developing C for AVR microcontrollers [here](http://www.tldp.org/HOWTO/Avr-Microcontrollers-in-Linux-Howto/x207.html)\r\n\r\navr-gcc seems to need a commandline option to specify the architecture.  Since\r\nthis is a device from my own imagination, it is not explicitly supported.  I use\r\n`-mmcu=atmega1284p` which is close.\r\n\r\nThere are some example programs in the c directory.  There are examples that contain\r\nthe entire program in the .c file so you can see exactly what is needed.\r\n\r\nHardware Registers\r\n------------------\r\nWhile the Instruction set is 8-bit AVR compatible.  The port mapped hardware is not intended to match any particular microcontroller.\r\n\r\nThe main Display output control is on port 0x40.  Writing 0x00 to that port puts the framebuffer onscreen in lowres mode.  Writing 0x01 displays hires mode.\r\nCurrent Display control Operations are  \r\n```\r\n    0x00 = Show Lowres display  (240x160)\r\n    0x01 = Show Highres display (480x360);\r\n    0x71 = blit 8 pixels per byte\r\n    0x72 = blit 4 pixels per byte\r\n    0x73 = blit 3 pixels per byte\r\n    0x74 = blit 2 pixels per byte\r\n    0x80 = Generate Mode 0   (fill framebuffer with 1.777bit per pixel data ( 16 bits per 9 pixels) )\r\n```\r\n*The file IOMapping.txt lists all hardware ports.  Should there be an\r\ninconsistancy in the documentation,  IOMapping.txt should be taken as\r\nthe correct form.*\r\n\r\nYou may write byte sized pixels (one of 256 colours in a fixed palette)\r\nto the framebuffer serially.\r\nLogically the frameBuffer is 512x392 and addressed with a 18 bit address in\r\nPorts 0x42,0x43,0x44  for SerialPixel address Low, Middle and High respectively.\r\n\r\nWriting to port 0x45 sets the pixel at the pixel adrress to the colour of the value\r\nwritten and advances the pixel address.\r\n\r\nWriting to port 0x46 multiplies the pixel at the pixel adrress by the colour of the value\r\nwritten and **does not** advance the pixel address.\\\r\n\r\nWriting to port 0x47 adds the pixel at the pixel adrress to the colour of the value\r\nwritten and advances the pixel address.\r\n\r\nYou cannot write directly from Program Memory to the display.  Serial output must\r\nbe conveyed by the CPU. Display mode generators and blitting operations read from\r\nRAM.  Consequently, image data will usually be transferred from Program Memory\r\nto RAM before it can be actively used.\r\n\r\nInput\r\n-----\r\n\r\nReading from ports 0x48 to 0x4f provides state based inputs\r\n\r\n````\r\n  input base = 0x48\r\n  button_state_0 = input base + 0  Left Up Right Down Enter Esc Ctrl Shift  \r\n  button_state_1 = input base + 1  A W D S SPACE Mouse1 Mouse2 Mouse3\r\n  mouseX = input base +2\r\n  mouseY = input base +3   mouse coordinates are in lowres pixels\r\n  ticker = input base +4   increments on each frame of host device.\r\n  timer  = input base +5   increments once per second\r\n````\r\n\r\nA serial input buffer is planned for keydown/keyup events but as yet no port\r\nis assigned.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}